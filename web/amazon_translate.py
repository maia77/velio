import boto3
import json
import os
import time
from typing import Dict, List, Optional
from flask import current_app
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading

class AmazonTranslateService:
    """ุฎุฏูุฉ ุงูุชุฑุฌูุฉ ุจุงุณุชุฎุฏุงู Amazon Translate ูุน ุชุญุณููุงุช ุงูุฃุฏุงุก ุงููุชูุฏูุฉ"""
    
    def __init__(self):
        # ุฅุนุฏุงุฏุงุช AWS - ูุฌุจ ุฅุถุงูุฉ ุงูููุงุชูุญ ูู ูุชุบูุฑุงุช ุงูุจูุฆุฉ
        self.aws_access_key_id = os.environ.get('AWS_ACCESS_KEY_ID', '')
        self.aws_secret_access_key = os.environ.get('AWS_SECRET_ACCESS_KEY', '')
        self.region_name = os.environ.get('AWS_REGION', 'us-east-1')
        
        # ุชููุฆุฉ ุนููู Amazon Translate
        try:
            self.translate_client = boto3.client(
                'translate',
                aws_access_key_id=self.aws_access_key_id,
                aws_secret_access_key=self.aws_secret_access_key,
                region_name=self.region_name,
                config=boto3.session.Config(
                    connect_timeout=10,
                    read_timeout=30,
                    retries={'max_attempts': 2}
                )
            )
            print("โ ุชู ุชููุฆุฉ Amazon Translate ุจูุฌุงุญ")
        except Exception as e:
            print(f"โ ุฎุทุฃ ูู ุชููุฆุฉ Amazon Translate: {e}")
            self.translate_client = None
        
        # ุฅุนุฏุงุฏุงุช ุงูุฃุฏุงุก ุงููุชูุฏูุฉ
        self.max_batch_size = 50  # ุฒูุงุฏุฉ ุญุฌู ุงููุฌููุนุฉ
        self.max_concurrent_requests = 10  # ุฒูุงุฏุฉ ุงูุทูุจุงุช ุงููุชุฒุงููุฉ
        # ุชุฎุฒูู ูุคูุช ุจุณูุท ุฏุงุฎู ุงูุฐุงูุฑุฉ ููุชุงุฆุฌ ุงูุชุฑุฌูุฉ
        self.translation_cache = {}
        self.cache_lock = threading.Lock()
        self.language_detection_cache = {}
        
        # ุฅุนุฏุงุฏุงุช ุงูุชุฑุฌูุฉ ุงูุณุฑูุนุฉ
        self.fast_translate_enabled = True
        self.preload_common_translations = True
        self.connection_pool_size = 5
        
        # ุชููุฆุฉ ุงูุชุฑุฌูุงุช ุงูุดุงุฆุนุฉ ูุณุจูุงู - ูุนุทู ูุคูุชุงู
        # if self.preload_common_translations:
        #     self._preload_common_translations()
    
    def _preload_common_translations(self):
        """ุชุญููู ุงูุชุฑุฌูุงุช ุงูุดุงุฆุนุฉ ูุณุจูุงู"""
        common_texts = [
            "Hello", "Welcome", "Thank you", "Please", "Yes", "No",
            "ูุฑุญุจุง", "ุฃููุง ูุณููุง", "ุดูุฑุง ูู", "ูู ูุถูู", "ูุนู", "ูุง"
        ]
        
        print("๐ ุชุญููู ุงูุชุฑุฌูุงุช ุงูุดุงุฆุนุฉ ูุณุจูุงู...")
        
        for text in common_texts:
            # ุชุฑุฌูุฉ ูู ุงูุฅูุฌููุฒูุฉ ุฅูู ุงูุนุฑุจูุฉ
            self.translate_text(text, 'ar', 'en')
            # ุชุฑุฌูุฉ ูู ุงูุนุฑุจูุฉ ุฅูู ุงูุฅูุฌููุฒูุฉ
            self.translate_text(text, 'en', 'ar')
        
        print(f"โ ุชู ุชุญููู {len(common_texts) * 2} ุชุฑุฌูุฉ ุดุงุฆุนุฉ")
    
    def translate_text(self, text: str, target_language: str, source_language: str = 'auto') -> Optional[str]:
        """ุชุฑุฌูุฉ ูุต ูุงุญุฏ ูุน ุชุญุณููุงุช ูุชูุฏูุฉ"""
        if not self.translate_client or not text:
            return None
        
        # ูุญุงููุฉ ุงููุฑุงุกุฉ ูู ุงููุงุด ุฃููุงู
        cache_key = f"{text}|||{source_language}|||{target_language}"
        with self.cache_lock:
            cached = self.translation_cache.get(cache_key)
            if cached is not None:
                return cached
        
        try:
            # ุชุญููู ุฑููุฒ ุงููุบุงุช
            target_lang_code = self._convert_language_code(target_language)
            source_lang_code = self._convert_language_code(source_language) if source_language != 'auto' else 'auto'
            
            # ุงูุชุดุงู ุงููุบุฉ ุงููุญุณู
            if source_lang_code == 'auto':
                detected_lang = self._fast_detect_language(text)
                source_lang_code = detected_lang if detected_lang else 'en'
            
            response = self.translate_client.translate_text(
                Text=text,
                SourceLanguageCode=source_lang_code,
                TargetLanguageCode=target_lang_code
            )
            
            translated_text = response['TranslatedText']
            
            # ุญูุธ ุงููุชูุฌุฉ ูู ุงููุงุด
            with self.cache_lock:
                self.translation_cache[cache_key] = translated_text
            
            return translated_text
            
        except Exception as e:
            print(f"โ ุฎุทุฃ ูู ุชุฑุฌูุฉ ุงููุต: {e}")
            return None
    
    def translate_text_preserve_format(self, text: str, target_language: str, source_language: str = 'auto') -> Optional[str]:
        """ุชุฑุฌูุฉ ูุต ูุน ุงูุญูุงุธ ุนูู ุชูุณูู ุงูุญุฑูู ุงููุงุจุชู"""
        if not self.translate_client or not text:
            return None
        
        # ุญูุธ ุงูุชูุณูู ุงูุฃุตูู
        original_text = text.strip()
        text_lower = original_text.lower()
        
        # ูุญุงููุฉ ุงููุฑุงุกุฉ ูู ุงููุงุด ูุน ุงูุญูุงุธ ุนูู ุงูููุงุชูุญ ุจุงูุญุฑูู ุงูุตุบูุฑุฉ
        cache_key = f"{text_lower}|||{source_language}|||{target_language}"
        with self.cache_lock:
            cached_translation = self.translation_cache.get(cache_key)
            if cached_translation is not None:
                return self._apply_original_format(cached_translation, original_text)
        
        try:
            # ุชุญููู ุฑููุฒ ุงููุบุงุช
            target_lang_code = self._convert_language_code(target_language)
            source_lang_code = self._convert_language_code(source_language) if source_language != 'auto' else 'auto'
            
            # ุงูุชุดุงู ุงููุบุฉ ุงููุญุณู
            if source_lang_code == 'auto':
                detected_lang = self._fast_detect_language(text_lower)
                source_lang_code = detected_lang if detected_lang else 'en'
            
            response = self.translate_client.translate_text(
                Text=text_lower,  # ุฅุฑุณุงู ุงููุต ุจุงูุฃุญุฑู ุงูุตุบูุฑุฉ ููุญุตูู ุนูู ุชุฑุฌูุฉ ุฃูุถู
                SourceLanguageCode=source_lang_code,
                TargetLanguageCode=target_lang_code
            )
            
            translated_text = response['TranslatedText']
            
            # ุชุทุจูู ุงูุชูุณูู ุงูุฃุตูู
            formatted_translation = self._apply_original_format(translated_text, original_text)
            
            # ุญูุธ ุงูุชุฑุฌูุฉ ุงูุฃุณุงุณูุฉ ูู ุงููุงุด ุจุงูุญุฑูู ุงูุตุบูุฑุฉ
            with self.cache_lock:
                self.translation_cache[cache_key] = translated_text
            
            return formatted_translation
            
        except Exception as e:
            print(f"โ ุฎุทุฃ ูู ุชุฑุฌูุฉ ุงููุต: {e}")
            return None
    
    def _apply_original_format(self, translated_text: str, original_text: str) -> str:
        """ุชุทุจูู ุชูุณูู ุงููุต ุงูุฃุตูู ุนูู ุงูุชุฑุฌูุฉ"""
        if not translated_text or not original_text:
            return translated_text
        
        # ุชูุณูู ุงููุตูุต ุฅูู ูููุงุช
        original_words = original_text.split()
        translated_words = translated_text.split()
        
        # ุชุทุจูู ุงูุชูุณูู ุนูู ูู ูููุฉ ูุชุฑุฌูุฉ
        formatted_words = []
        for i, (orig_word, trans_word) in enumerate(zip(original_words, translated_words)):
            if orig_word.isupper():
                formatted_words.append(trans_word.upper())
            elif orig_word.istitle():
                # ุชุทุจูู ุงูุญุฑู ุงูุฃูู ูุงุจุชู ุนูู ุงููุต ุงูุนุฑุจู
                formatted_words.append(self._capitalize_arabic_word(trans_word))
            else:
                formatted_words.append(trans_word)
        
        # ุฅุถุงูุฉ ุงููููุงุช ุงููุชุฑุฌูุฉ ุงูุฅุถุงููุฉ ุฅุฐุง ูุงูุช ุงูุชุฑุฌูุฉ ุฃุทูู
        if len(translated_words) > len(original_words):
            formatted_words.extend(translated_words[len(original_words):])
        
        return ' '.join(formatted_words)
    
    def _capitalize_arabic_word(self, word: str) -> str:
        """ุชุญููู ุงูุญุฑู ุงูุฃูู ุฅูู ูุงุจุชู ูู ุงููููุฉ ุงูุนุฑุจูุฉ"""
        if not word or len(word) == 0:
            return word
        
        # ุงูุญุตูู ุนูู ุงูุญุฑู ุงูุฃูู
        first_char = word[0]
        # ุงูุญุตูู ุนูู ุจุงูู ุงููููุฉ
        rest_of_word = word[1:] if len(word) > 1 else ""
        
        # ุชุญููู ุงูุญุฑู ุงูุฃูู ุฅูู ูุงุจุชู
        if first_char.isalpha():
            capitalized_first = first_char.upper()
            return capitalized_first + rest_of_word
        else:
            return word
    
    def _fast_detect_language(self, text: str) -> Optional[str]:
        """ุงูุชุดุงู ุณุฑูุน ููุบุฉ"""
        # ุฅุฒุงูุฉ ุงูุชุญูู ูู ุงูุชุฎุฒูู ุงููุคูุช ุงููุญูู ูุถูุงู ุงุณุชุฎุฏุงู Amazon Translate API ููุท
        # if text in self.language_detection_cache:
        #     return self.language_detection_cache[text]
        
        # ุงูุชุดุงู ุณุฑูุน ุจูุงุกู ุนูู ุงูุฃุญุฑู
        if any('\u0600' <= char <= '\u06FF' for char in text):
            detected_lang = 'ar'
        elif any('\u0041' <= char <= '\u005A' or '\u0061' <= char <= '\u007A' for char in text):
            detected_lang = 'en'
        else:
            detected_lang = 'en'  # ุงูุชุฑุงุถู
        
        # ุฅุฒุงูุฉ ุญูุธ ุงูุชุฎุฒูู ุงููุคูุช ุงููุญูู
        # self.language_detection_cache[text] = detected_lang
        
        return detected_lang
    
    def translate_batch(self, texts: List[str], target_language: str, source_language: str = 'auto') -> List[Optional[str]]:
        """ุชุฑุฌูุฉ ูุฌูุนุฉ ูุญุณูุฉ ุฌุฏุงู"""
        if not self.translate_client or not texts:
            return [None] * len(texts)
        
        # ุฅุฒุงูุฉ ุงููุตูุต ุงููุงุฑุบุฉ ูุงูุชูุฑุงุฑ
        unique_texts = list(set([text.strip() for text in texts if text.strip()]))
        
        if not unique_texts:
            return [None] * len(texts)
        
        # ุงุณุชุฎุฏุงู ุงููุงุด ููุชุงุฆุฌ ุณุงุจูุฉ ูุชูููู ุนุฏุฏ ุงูุงุชุตุงูุงุช
        cached_results = {}
        texts_to_translate = []
        with self.cache_lock:
            for text in unique_texts:
                cache_key = f"{text}|||{source_language}|||{target_language}"
                if cache_key in self.translation_cache:
                    cached_results[text] = self.translation_cache[cache_key]
                else:
                    texts_to_translate.append(text)
        
        # with self.cache_lock:
        #     for text in unique_texts:
        #         cache_key = f"{text}_{source_language}_{target_language}"
        #         if cache_key in self.translation_cache:
        #             cached_results[text] = self.translation_cache[cache_key]
        #         else:
        #             texts_to_translate.append(text)
        
        # ุชุฑุฌูุฉ ุงููุตูุต ุงูุฌุฏูุฏุฉ ููุท
        if texts_to_translate:
            translated_results = self._ultra_fast_batch_translate(texts_to_translate, target_language, source_language)
            
            # ุฏูุฌ ุงููุชุงุฆุฌ ูุน ุงูุชุฎุฒูู ุงููุคูุช
            for i, text in enumerate(texts_to_translate):
                if i < len(translated_results) and translated_results[i]:
                    cached_results[text] = translated_results[i]
                    with self.cache_lock:
                        self.translation_cache[f"{text}|||{source_language}|||{target_language}"] = translated_results[i]
        
        # ุฅุฑุฌุงุน ุงููุชุงุฆุฌ ุจุงูุชุฑุชูุจ ุงูุฃุตูู
        results = []
        for text in texts:
            text_clean = text.strip()
            if text_clean in cached_results:
                results.append(cached_results[text_clean])
            else:
                results.append(None)
        
        return results
    
    def _ultra_fast_batch_translate(self, texts: List[str], target_language: str, source_language: str = 'auto') -> List[Optional[str]]:
        """ุชุฑุฌูุฉ ูุฌูุนุฉ ูุงุฆูุฉ ุงูุณุฑุนุฉ"""
        if not texts:
            return []
        
        # ุชูุณูู ุงููุตูุต ุฅูู ูุฌููุนุงุช ุฃูุจุฑ
        batches = [texts[i:i + self.max_batch_size] for i in range(0, len(texts), self.max_batch_size)]
        
        results = []
        
        # ุงุณุชุฎุฏุงู ThreadPoolExecutor ูุน ุนุฏุฏ ุฃูุจุฑ ูู ุงูุนูุงู
        with ThreadPoolExecutor(max_workers=self.max_concurrent_requests) as executor:
            # ุฅูุดุงุก ููุงู ุงูุชุฑุฌูุฉ
            future_to_batch = {}
            for batch in batches:
                future = executor.submit(self._translate_single_batch_optimized, batch, target_language, source_language)
                future_to_batch[future] = batch
            
            # ุฌูุน ุงููุชุงุฆุฌ
            for future in as_completed(future_to_batch):
                try:
                    batch_results = future.result()
                    results.extend(batch_results)
                except Exception as e:
                    print(f"โ ุฎุทุฃ ูู ุชุฑุฌูุฉ ุงููุฌููุนุฉ: {e}")
                    batch = future_to_batch[future]
                    results.extend([None] * len(batch))
        
        return results
    
    def _translate_single_batch_optimized(self, texts: List[str], target_language: str, source_language: str = 'auto') -> List[Optional[str]]:
        """ุชุฑุฌูุฉ ูุฌููุนุฉ ูุงุญุฏุฉ ูุญุณูุฉ"""
        if not texts:
            return []
        
        try:
            # ุงูุชุดุงู ุงููุบุฉ ูุฑุฉ ูุงุญุฏุฉ ูููุฌููุนุฉ
            source_lang_code = self._convert_language_code(source_language)
            if source_lang_code == 'auto':
                detected_lang = self._fast_detect_language(texts[0])
                source_lang_code = detected_lang if detected_lang else 'en'
            
            target_lang_code = self._convert_language_code(target_language)
            
            # ุชุฑุฌูุฉ ูู ูุต ูู ุงููุฌููุนุฉ
            results = []
            for text in texts:
                try:
                    response = self.translate_client.translate_text(
                        Text=text,
                        SourceLanguageCode=source_lang_code,
                        TargetLanguageCode=target_lang_code
                    )
                    
                    translated_text = response['TranslatedText']
                    
                    # ุญูุธ ูู ุงูุชุฎุฒูู ุงููุคูุช
                    cache_key = f"{text}_{source_language}_{target_language}"
                    with self.cache_lock:
                        self.translation_cache[cache_key] = translated_text
                    
                    results.append(translated_text)
                    
                except Exception as e:
                    print(f"โ ุฎุทุฃ ูู ุชุฑุฌูุฉ ุงููุต '{text[:30]}...': {e}")
                    results.append(None)
            
            print(f"โ ุชู ุชุฑุฌูุฉ ูุฌููุนุฉ ูู {len(texts)} ูุต")
            return results
            
        except Exception as e:
            print(f"โ ุฎุทุฃ ูู ุชุฑุฌูุฉ ุงููุฌููุนุฉ: {e}")
            return [None] * len(texts)
    
    def clear_cache(self):
        """ูุณุญ ุงูุชุฎุฒูู ุงููุคูุช"""
        with self.cache_lock:
            self.translation_cache.clear()
            self.language_detection_cache.clear()
        print("โ ุชู ูุณุญ ุงูุชุฎุฒูู ุงููุคูุช")
    
    def get_cache_stats(self):
        """ุงูุญุตูู ุนูู ุฅุญุตุงุฆูุงุช ุงูุชุฎุฒูู ุงููุคูุช"""
        with self.cache_lock:
            return {
                'translation_cache_size': len(self.translation_cache),
                'language_detection_cache_size': len(self.language_detection_cache),
                'total_cache_size': len(self.translation_cache) + len(self.language_detection_cache)
            }
    
    def translate_product(self, product_data: Dict, target_language: str) -> Dict:
        """
        ุชุฑุฌูุฉ ุจูุงูุงุช ููุชุฌ ูุงููุฉ
        
        Args:
            product_data: ุจูุงูุงุช ุงูููุชุฌ
            target_language: ุงููุบุฉ ุงููุณุชูุฏูุฉ
        
        Returns:
            ุจูุงูุงุช ุงูููุชุฌ ุงููุชุฑุฌูุฉ
        """
        if not self.translate_client:
            return product_data
        
        translated_data = product_data.copy()
        
        # ุชุฑุฌูุฉ ุงูุญููู ุงููุตูุฉ
        fields_to_translate = ['name', 'description', 'category', 'brand']
        
        for field in fields_to_translate:
            if field in product_data and product_data[field]:
                translated_text = self.translate_text(
                    product_data[field], 
                    target_language, 
                    'en'  # ููุชุฑุถ ุฃู ุงููุต ุงูุฃุตูู ุจุงููุบุฉ ุงูุฅูุฌููุฒูุฉ
                )
                if translated_text:
                    translated_data[f'{field}_{target_language}'] = translated_text
        
        return translated_data
    
    def detect_language(self, text: str) -> Optional[str]:
        """
        ุงูุชุดุงู ูุบุฉ ุงููุต
        
        Args:
            text: ุงููุต ุงููุฑุงุฏ ุงูุชุดุงู ูุบุชู
        
        Returns:
            ุฑูุฒ ุงููุบุฉ ุงูููุชุดูุฉ
        """
        if not self.translate_client or not text:
            return None
        
        try:
            # ุงุณุชุฎุฏุงู Amazon Comprehend ุจุฏูุงู ูู Translate ููุงูุชุดุงู
            import boto3
            comprehend = boto3.client(
                'comprehend',
                aws_access_key_id=self.aws_access_key_id,
                aws_secret_access_key=self.aws_secret_access_key,
                region_name=self.region_name
            )
            
            response = comprehend.detect_dominant_language(Text=text)
            if response['Languages']:
                detected_language = response['Languages'][0]['LanguageCode']
                confidence = response['Languages'][0]['Score']
                print(f"โ ุชู ุงูุชุดุงู ุงููุบุฉ: {detected_language} (ุซูุฉ: {confidence:.2f}%)")
                return detected_language
            else:
                return None
            
        except Exception as e:
            print(f"โ ุฎุทุฃ ูู ุงูุชุดุงู ุงููุบุฉ: {e}")
            # ูุญุงููุฉ ุงูุชุดุงู ุจุณูุท ุจูุงุกู ุนูู ุงูุฃุญุฑู
            if any('\u0600' <= char <= '\u06FF' for char in text):
                return 'ar'  # ุนุฑุจู
            elif any('\u0041' <= char <= '\u005A' or '\u0061' <= char <= '\u007A' for char in text):
                return 'en'  # ุฅูุฌููุฒู
            else:
                return 'en'  # ุงูุชุฑุงุถู
    
    def get_supported_languages(self) -> List[Dict]:
        """
        ุงูุญุตูู ุนูู ูุงุฆูุฉ ุงููุบุงุช ุงููุฏุนููุฉ
        
        Returns:
            ูุงุฆูุฉ ุงููุบุงุช ุงููุฏุนููุฉ
        """
        if not self.translate_client:
            return []
        
        try:
            response = self.translate_client.list_languages()
            languages = response['Languages']
            
            # ุชุตููุฉ ุงููุบุงุช ุงููููุฉ ููุท
            important_languages = ['ar', 'en', 'fr', 'es', 'de', 'it', 'pt', 'ru', 'ja', 'ko', 'zh']
            filtered_languages = [
                lang for lang in languages 
                if lang['LanguageCode'] in important_languages
            ]
            
            return filtered_languages
            
        except Exception as e:
            print(f"โ ุฎุทุฃ ูู ุงูุญุตูู ุนูู ุงููุบุงุช ุงููุฏุนููุฉ: {e}")
            return []
    
    def _convert_language_code(self, language_code: str) -> str:
        """
        ุชุญููู ุฑูุฒ ุงููุบุฉ ุฅูู ุงูุชูุณูู ุงููุทููุจ ูู Amazon Translate
        
        Args:
            language_code: ุฑูุฒ ุงููุบุฉ
        
        Returns:
            ุฑูุฒ ุงููุบุฉ ุงููุญูู
        """
        # ุชุญููู ุฑููุฒ ุงููุบุงุช ุงูุดุงุฆุนุฉ
        language_mapping = {
            'ar': 'ar',      # ุงูุนุฑุจูุฉ
            'en': 'en',      # ุงูุฅูุฌููุฒูุฉ
            'fr': 'fr',      # ุงููุฑูุณูุฉ
            'es': 'es',      # ุงูุฅุณุจุงููุฉ
            'de': 'de',      # ุงูุฃููุงููุฉ
            'it': 'it',      # ุงูุฅูุทุงููุฉ
            'pt': 'pt',      # ุงูุจุฑุชุบุงููุฉ
            'ru': 'ru',      # ุงูุฑูุณูุฉ
            'ja': 'ja',      # ุงููุงุจุงููุฉ
            'ko': 'ko',      # ุงูููุฑูุฉ
            'zh': 'zh',      # ุงูุตูููุฉ
            'auto': 'auto'   # ุงูุชุดุงู ุชููุงุฆู
        }
        
        return language_mapping.get(language_code.lower(), language_code.lower())
    
    def is_available(self) -> bool:
        """
        ุงูุชุญูู ูู ุชููุฑ ุฎุฏูุฉ ุงูุชุฑุฌูุฉ
        
        Returns:
            True ุฅุฐุง ูุงูุช ุงูุฎุฏูุฉ ูุชุงุญุฉ
        """
        return self.translate_client is not None

# ุฅูุดุงุก ูุณุฎุฉ ุนุงูุฉ ูู ุฎุฏูุฉ ุงูุชุฑุฌูุฉ
translate_service = AmazonTranslateService() 